function [iec,ienode,isbc,isbce,isonb,lisbce_1,lisbce_2,mx_nbr_elem,ne,nbe,nbsn,nbve,nbvt,niec,...
          nisbce_1,nisbce_2,nisbce_3,ntrg,ntsn,ntve,ncv,ncv_i,sitac,sitae,sitau,...
          deltux,deltuy,dltxc,dltxe,dltxyc,dltxye,dltyc,dltye,dltxne,dltyne,xijc,xije,yijc,yije,epor,nflag] ...
     =  triangle_grid_edge(nv,vx,vy,xc,yc,iobcn,i_obc_n,spherical)
%
%function [iec,ienode,isbc,isbce,isonb,lisbce_1,lisbce_2,mx_nbr_elem,ne,nbe,nbsn,nbve,nbvt,niec,...
%          nisbce_1,nisbce_2,nisbce_3,ntrg,ntsn,ntve,ncv,ncv_i,sitac,sitae,sitau,...
%          deltux,deltuy,dltxc,dltxe,dltxyc,dltxye,dltyc,dltye,dltxne,dltyne,xijc,xije,yijc,yije,epor,nflag] ...
%     =  triangle_grid_edge(nv,vx,vy,xc,yc,,iobcn,i_obc_n,spherical)
%
%  This program is used to define the non-overlapped, unstructured             
%  	triangular meshes used for flux computations. the mesh could be             
%  	created using the commerical software called "sms8.0" or other              
%  	mesh generation programs. The mesh file generated by sms8.0 can             
%  	be directly used for this subroutine, while the mesh file                   
%  	generated using other programs must be coverted the data format             
%  	to meet the required format used here.                                      
%
%  Inputs:
%       xc(n)            --- element center x coordinates
%       yc(n)            ---                y
%       nv(n,3)          --- element to node connectivity (nodes are arranged
%                            in counter-clockwise order)
%       vx(m)            --- node x coordinates
%       vy(m)            --- node y coordinates
%       iobcn            --- number of obc nodes
%       i_obc_n(1:iobcn) --- node numbers of obc nodes
%       spherical        --- 0 for plane, 1 for spherical
%
%  Outputs:  
%	deltux(1:n,1:3)   --- x coordinate interval size for spherical coord of edges of each element
%	deltuy(1:n,1:3)	  --- y coordiante interval size for spherical coord of edges of each element
%	dltxne(1:ne,1:2)  --- dx in spherical coordinate for the tracer control volume edges that
%                             are connected with all element edges at midpoint of element edges. dltxne(i,1) is 
%                             the x coordinate difference of the trace control volume on side of the
%                             element edge, and dltxne(i,2) is within the element on the other side 
%                             of the edge. It is calculated by subtracting the x coord of element center
%                             from the x coord of the element edge midpoint
%       dltyne(1:ne,1:2)  --- dy in spherical coordinate for tracer control volume edges.
%                             
%       dltxe(1:nc)       --- dx of an edge of a tracer control volume
%	dltye(1:nc)	  --- dy of an edge of a tracer control volume
%       dltxye(1:nc)	  --- sqrt(dltxe^2+dltye^2) (length of an edge of the tracer control volume)
%       sitae(1:nc)       --- slope of an edge of a control volume (atan2(dltye,dltxe))
%       sitau(1:nc)       --- slope of an element edge in spherical coordinate
%
%	epor(1:n)	  --- element porosity, 0 if the element is on boundary
%       ne                --- total number of unique edges of all triangular elements in the grid
%       ienode(1:ne,1:2)  --- node number of a given edge (edge to node)
%	iec(1:ne,1:2)	  --- element numbers of the two elements sharing a given edge (edge to element)
%                             For counter-clockwised grid, look from starting node (ienode(i,1)) 
%                                 towards ending node (ienode(i,2)) for edge i
%	                               iec(i,1) is the element on the left side
%			               iec(i,2) is the elemnt on the rigt side
%                             for clockwised grid system, look from starting node (ienode(i,1))
%                                 towards ending node (ienode(i,2)) for edge i
%                                      iec(i,1) is the element on the right side
%                                      iec(i,2) is the element on the left side
%       xijc(1:ne)        --- x coordinate of the mid point of an edge
%       yijc(1:ne)        --- y coordiante of the mid point of an edge
%       dltxc(1:ne)       --- dx of an edge (i.e. x coordinate difference of an edge)
%       dltyc(1:ne)       --- dy of an edge (i.e. y coordinate difference of an edge)
%       dltxyc(1:ne)      --- =sqrt(dltxc^2+dltyc^2) (length of an edge)
%       sitac(1:ne)       --- slope of an element edge (atan2(dltyc,dltxc)) in cartesian coordinate
%       nbe(1:n,1:3)      --- elemement numbers of a given element's 3 neighbors
%                              nbe(i,1) stores the interfacing elemnt that bounds edge n2-n3
%                              nbe(i,2)                                                n1-n3
%                              nbe(i,3)                                                n1-n2
%                              where n1,n2,n3 are the node numbers of element i
%                              value is zero if one element edge does not have corresponding neighbor
%
%        isonb(m)         ---flag of boundary type of a given node
%                                0--this node is in interior
%                                1--this node is on solid boundary
%                                2--this node is on open boundary
%
%	isbce(1:n)        ---type of boundary condition for a given element
%			 	 0--this element is in interior
%				 1--this element is on solid boundary
%				 2--this element is on open boundary
%				 3--this element has two solid boundaries
%
%        isbc(1:ne)       ---0 if edge is in interior, 1 if edge is on boundary
%
%        nisbce_1         --- number of elements with boundary type = 1 (1 solid boundary)
%        nisbce_2         --- number of elements with boundary type = 2 (open boundary)
%        nisbce_3         --- number of elements with boundary type = 3 (has 2 solid boundary)
%
%	lisbce_1(1:nisbce_1)      --- list of elements that have isbce value equal to 1
%	lisbce_2(1:nisbce_2)      --- list of elements that have isbce value equal to 2
%	lisbce_3(1:nisbce_3)      --- list of elements that have isbce value equal to 3
%	mx_nbr_elem	          --- maximum number of elements surrounding a node in the grid system
%                                      mx_nbr_elem=max(ntve(1:m))
%       ntve(1:m)                 --- total number of surrounding elements of a node
%	nbve(1:m,1:mx_nbr_elem+1) --- element number of surrounding elements of a given node
%                                     For clockwised grid system, the second dimension of this array
%                                         is indexed clockwise, i.e. element nbve(i,2) is clockwise to element nbve(i,1)
%                                         surrounding given node i, until the last surroundingelement nbve(i,ntve(i))
%                                     For counter-clockwised grid system, the second dimension of this array
%                                         is indexed counter-clockwise
%	nbvt(1:m,1:mx_nbr_elem+1) --- 1, 2, or 3, i.e. the local node id of an surrounding element of a node i
%                                     that happens to be the same as the given node i (i=1,...,m)
%	ncv	                  --- number of control volumes edges, must be equal to 3*nt (including halo elements)
%	ncv_i                     --- number of control volumes edges, must be equal to 3*n  (all elements in child proc
%                                     domain)
%	nflag                     --- 0 if no elements that are single-isolated
%                                     1 if there is an element that have no sharing edges with others
%	niec(1:nc,1:2)            --- two node numbers of the trianglular grid edge that a TCE edge is 
%                                     intersecting with, i.e. for each TCE edge, it is purpendicular to 
%                                     a triangle element edge, and the nodes of the triangular element 
%                                     edge are recorded in niec(:,1) and niec(:,2). For counter-clockwised grid system
%                                     node ia=niec(i,1)is on the right, node ib=niec(i,2) is on the left, when looking
%                                     from the starting point (xije(i,1),yije(i,2))towards the 
%                                     ending point (xije(i,2), yije(i,2)) of the i'th TCE edge.
%                                     For clockwise grid system, node ia =niec(i,1)is on the left and node ib=niec(i,2) is 
%                                     on the right when looking from starting point towards the ending point
%
%	ntrg(1:nc)  	          --- element numbers of a control volume's edge
%	ntsn(1:m)	          --- total number of surrounding nodes of a node
%       nbsn(1:m,1:mx_nbr_elem+3) --- node number of all surroinding nodes of a given node
%                                     the last node returns to the first node (
%                                     nodes are recorded counter-clockwise for counter-clockwise grid
%                                     clockwise for clockwise grid).
%                                     For boundary nodes, the last surrounding node and the 
%                                     first surrounding node are taken as the
%                                     same as the given node itself.
%       xije(1:nt*3,1:2)          --- x coordinates of the edges of a tracer control volume
%                                     each edge has 2 points.  First column (:,1) gives the the starting point
%                                     of the edge which is always at a surrounding elemnt's center (xc).
%                                     Second column (:,2) gives the ending point of the edge
%                                     which is always at the mid point of an edge of the mesh (xijc)
%       yije(1:nt*3,1:2)          --- starting (element center) (:,1) and ending point (mid point of edge) (:,2)
%                                     of a tracer control volume's edge 's y coordinates
%
%  Code and documentation: 
%
%     Wen Long @ PNNL/BSRC, Seattle, WA, 04/02/2013
%

%
%   Temporary variables used in ths function:
%
%    deltx        --- dx of an edge of an element in spherical coord
%    delty        --- dy of an edge of an element in spherical coord
%
%     x1_dp       --- temp x coordinate of an edge's first point (start) (edge can be element edge or TCE edge)
%     y1_dp       --- temp y coordinate of an edge's first point (start) (edge can be element egge or TCE edge)
%     x2_dp       --- temp x coordinate of an edge's 2nd point (end) (edge can be element edge or TCE edge)
%     y2_dp       --- temp y coordinate of an edge's 2nd point (end) (edge can be element edge or TCE edge)
%
%     dtmp        --- temporarily used in calculating dltxye
%     ibcetmp     --- useless (involved in calculating isbce from isonb, but actually not used)
%     iset        --- temporary variable to mark whether a node has been searched
%                     during the process of finding all edges in the grid
%     iney        --- temporarily used for finding elements sharing a given edge (iec)
%                     it stores element number under search
%
%     cellcnt(1:mt)           --- temporary,number of cells(elements) a given node belongs to
%                                 used for calculating nbe
%     cells(1:mt,1:cellcnt)   --- temporary,the element numbers that a given node belongs to
%                                 used for calculating nbe
%
%     nbet  --useless
%
%     itmp1       --- temporary boundary type of first node of a given element
%     itmp2       --- temporary boundary type of second node of a given element
%     itmp3       --- temporary boundary type of third node of a given element
%
%     j1          --- temporary index of an element's element to node connectivity (nv)
%     j2          --- temporary index of an element's element to node connectivity (nv)
%     jj          --- temporary local index (1,2,3) of one of the surrounding element
%                     of a node's 3 node numbers. i.e. used to cycle through
%                     all 3 nodes of a given surrounding element of a given node
%     jjb         --- tempoary index in nb_tmp, used in looking for
%                     surrounding element index of a given node that is on the boundary
%
%     n1          --- first node of an element
%     n2          --- second node of an element
%     n3          --- third node of an element
%
%     nb_tmp(1:m,1:2)    ---element number (:,1) and the corresponding local node number
%                              (:,2) of the element that is surrounding a given node
%
%     ncnt   --- temporarily used in finding number of elements surrounding a node ntve
%
%     nctmp  --- temporarily variable used in caluclating ncv
%     ii     --- tempoary variable storing the element number of a node's
%                surrounding element. It is used for cycling through all
%                the surrounding elements of a node.
%
%     temp   --- temporarily used in finding iec (elements that share an edge)
%     temp2  --- temporarily used in finding ienode (nodes of an edge)
%
%     ntmp   --- temporarily used when trying to find npt
%     npt    --- temporarily used when trying to find xije
%
%     xtmp   --- tempoary angle used in calculating dltxc,dltyc and dltxe,dltye in spherical coord
%     xtmp1  --- tempoary angle used in calculating dltxc,dltyc and dltxe,dltye in spherical coord
%
%     ncetmp --- temporarily used in calculating xije, yije
%

%==============================================================================|
%   find neighboring elements, mark boundary nodes and elements                |
%									       |
%   nbe(n,3) :  nbe(i,j) = identity of nbor elmnt to tri i on edge j           |
%   isbce(n) :  described in subroutine heading			               |	
%   isonb(m) :  described in subroutine heading			               |	
%==============================================================================|

    if(spherical)
      deg2rad=3.14159265/180.0;
      rearth=6371000.0;
      tpi=deg2rad*rearth;   %length(m) per degree on earth-sphere's great circle
    end

%
%----determine nbe(i=1:n,j=1:3): index of 1 to 3 neighboring elements----------%
%

    n=size(nv,1);  %number of elements
    m=size(vx,1);  %number of nodes
    nhn=0;         %number of halo nodes
    nhe=0;
    mt=m+nhn;
    nt=n+nhe;

%    nbet=zeros([nt,3]);
    cells=zeros([mt,50]);
    cellcnt=zeros([mt,1]); 

   %loop over all elements 1:nt

   for i=1:nt
       n1 = nv(i,1) ; cellcnt(n1) = cellcnt(n1)+1;  %increment number of elements that n1 belongs to
       n2 = nv(i,2) ; cellcnt(n2) = cellcnt(n2)+1;  %increment number of elements that n2 belongs to
       n3 = nv(i,3) ; cellcnt(n3) = cellcnt(n3)+1;  %increment number of elements that n3 belongs to
       cells(n1,cellcnt(n1)) = i;   %record the corresponding element number that n1 belongs to
       cells(n2,cellcnt(n2)) = i;   %record the corresponding element number that n2 belongs to
       cells(n3,cellcnt(n3)) = i;   %record the corresponding element number that n3 belongs to
   end

   %give error if one node is shared by more than 50 elements
   if(max(cellcnt(:)) > 50)
      error(['bad maxval(cellcnt):' num2str(max(cellcnt(:)))]);
   end

   %loop over all elements to find 3 elements that bound element i by the edges of elements i
   for i=1:nt
       n1 = nv(i,1);
       n2 = nv(i,2);
       n3 = nv(i,3);
       for j1 = 1:cellcnt(n1)  %loop over surrounding elements of node n1
       for j2 = 1:cellcnt(n2)  %loop over surrounding elements of node n2
           if((cells(n1,j1) == cells(n2,j2)) &&  cells(n1,j1) ~= i) 
              nbe(i,3) = cells(n1,j1); %find the element that shares edge n1-n2 with element i
                                  %storing it in nbe(i,3), i.e. poosite to n3
           end
       end
       end

       for j2 = 1:cellcnt(n2)  %loop over surrounding elements of n2
       for j3 = 1:cellcnt(n3)  %loop over surrounding elements of n3
           if((cells(n2,j2) == cells(n3,j3)) &&  cells(n2,j2) ~= i) 
               nbe(i,1) = cells(n2,j2);  %find the element that shares edge n2-n3 with element i
                                   %store it in nbe(i,1),i.e. opposite to n1
           end
       end
       end

       for j1 = 1:cellcnt(n1)  %loop over surrounding elemnts of n1
       for j3 = 1:cellcnt(n3)  %loop over surrounding elemnts of n3
           if((cells(n1,j1) == cells(n3,j3)) && cells(n1,j1) ~= i)
              nbe(i,2) = cells(n3,j3);  %find the element that shares edge n1-n3 with element i 
           end                          %stoe it in nbe(i,2)
       end
       end
   end

   clear 'cells','cellcnt' ; 
   display('  neighbor finding    :    complete');

%
%--ensure all elements have at least one neighbor
%
   nflag = 0;
   for i=1:nt                 %loop through all elements
     if(sum(nbe(i,1:3))==0)   %if no neighboring elemnts, then give error
       nflag = 1;
       warning(['element ',num2tr(i),' at (',num2str(xc(i)) ',' num2str(yc(i)),') has no neighbors'])
     end
   end
   if(nflag == 1)
     error(['error: some elements have no neighbors...']); 
     exit;
   end
     
%
%----if element on boundary set isbce(i)=1 and isonb(j)=1 for boundary nodes j-%
%

   for i=1:nt   %loop through all elements 
     if(min([nbe(i,1),nbe(i,2),nbe(i,3)])==0)  %if one of the edge of the element
                                             %has no neighboring elemnt
                                             %then this element must be on the boundary
       isbce(i) = 1;  %mark this element as on boundary

       if(nbe(i,1) == 0)  %edge of nodes2-3 of element i is on boundary, hence mark
                          %node 2 and node 3 of the element as being on boundary
         isonb(nv(i,2)) = 1 ; isonb(nv(i,3)) = 1;
       end

       if(nbe(i,2) ==0)   %edge of nodes 1-3 of element i is on boundary, hence mark
                          %node 1 and node 3 of the element as being on boundary
         isonb(nv(i,1)) = 1 ; isonb(nv(i,3)) = 1;
       end

       if(nbe(i,3) ==0)   %edge of nodes 1-2 of element i is on boundary, hence mark 
                          %node 2 and node 3 of the elemtn as being on boundary
         isonb(nv(i,1)) = 1 ; isonb(nv(i,2)) = 1;
       end
     end
   end

   display(['  isonb setting       :    complete']); 
        
%==============================================================================|
%             define ntve, nbve, nbvt                                          %
%                                                                              %
% ntve(1:m):           total number of the surrounding triangles               %
%                      connected to the given node                             %                                        
% nbve(1:m, 1:ntve+1): the identification number of surrounding                %
%                      triangles with a common node (counted conunterclockwise %
%                      for counter-clockwise grids, clockwise for clockwise    %
%                      grids.                                                  %
%                      For interior elements the last point (ntve+1) is the    %
%                      same as the first point                                 % 
% nbvt(1:m,ntve+1)   : the idenfication number of a given node over            %
%                      each individual surrounding triangle(counted            %
%                      counter-clockwise for counter-clockwise grid and        %
%                      clock-wise for clockwise grid)                          %
% ntsn(1:m):           total number of surrounding nodes                       %
% nbsn(1:m, ntsn):     the identification number of surrounding nodes          %
%                      (counted counter-clockwise for counter-clockwise grids  %
%                      and clockwise for clockwise grid system)                %
% nbse(1:m,2*ntsn):    the identification number of control volume's           %
%                      edges between two neighbor nodes (never used)           %
%==============================================================================|

%
%----determine max number of surrounding elements------------------------------%
%
   mx_nbr_elem = 0;
   for i=1:m   %loop through all nodes
     ncnt = 0;
     for j=1:nt  %loop through all elements
       if( (nv(j,1)-i)*(nv(j,2)-i)*(nv(j,3)-i) == 0) 
         ncnt = ncnt + 1;  %if found an element that has
                          %one of its nodes collapsing with node i
                          %then increment the number of elements
                          %that this node i belongs to by 1
       end
     end
     mx_nbr_elem = max(mx_nbr_elem,ncnt) ;
   end

%
%----allocate arrays based on mx_nbr_elem--------------------------------------%
% 
    nbve=zeros([m, mx_nbr_elem+1]);
    nbvt=zeros([m, mx_nbr_elem+1]);
    nbsn=zeros([m, mx_nbr_elem+3]); 

%
%--determine number of surrounding elements for node i = ntve(i)---------------%
%--determine nbve - indices of neighboring elements of node i------------------%
%--determine nbvt - index (1,2, or 3) of node i in neighboring element---------%
%
       
   for i=1:m   %loop through all nodes

     ncnt=0 ;   %check all elements and collect number of elements that 
                %share node i
     for j=1:nt
       if ( (nv(j,1)-i)*(nv(j,2)-i)*(nv(j,3)-i) == 0)
         ncnt = ncnt+1;  %found one element j that has node i as its node
         nbve(i,ncnt)=j; %record the element id

         %record the corresponding local node id of the element j
         if((nv(j,1)-i) == 0)
            nbvt(i,ncnt)=1;  %element j has node i as its 1st node
         end

         if((nv(j,2)-i) == 0)
            nbvt(i,ncnt)=2;  %element j has node i as its 2nd node
         end

         if((nv(j,3)-i) == 0)
            nbvt(i,ncnt)=3;  %element j has node i as its 3rd node
         end
       end
     end
     ntve(i)=ncnt;   %write down total nubmer of surrounding elements 
                     %for node i
   end

%
%--order elements surrounding a node to go in a cyclical procession------------%
%--determine ntsn  = number of nodes surrounding a node (+1)-------------------%
%--determine nbsn  = node numbers of nodes surrounding a node------------------%
%
   nb_tmp=zeros([m,mx_nbr_elem+1]);

   for i=1:m  %loop through all nodes

     if(isonb(i) == 0)  %if this node is NOT on boundary

       nb_tmp(1,1)=nbve(i,1);  %take the first element that shares node i
       nb_tmp(1,2)=nbvt(i,1);  %take the local node number of the first sharing element

       for j=2:ntve(i)+1     %loop through the first to the last sharing element

         ii=nb_tmp(j-1,1) ;   %j-1'th sharing element
         jj=nb_tmp(j-1,2) ;   %j-1'th sharing element's sharing local node ID

         nb_tmp(j,1)=nbe(ii,jj+1-floor((jj+1)/4)*3); % Next element that shares
                                                   % an edge with element ii
                            %if jj=1 ==>  jj+1-floor((jj+1)/4)*3 = 2
                            %if jj=2 ==>  jj+1-floor((jj+1)/4)*3 = 3
                            %if jj=3 ==>  jj+1-floor((jj+1)/4)*3 = 1

         jj=nb_tmp(j,1);     %fetch the next sharing element
 
         if((nv(jj,1)-i) == 0) %if the next sharing element is sharing local node ID 1 with i
                               %then set the local ID to be 1
           nb_tmp(j,2)=1;
         end
 
         if((nv(jj,2)-i) == 0) %next sharing element is sharing local node ID 2 with i
           nb_tmp(j,2)=2;
         end

         if((nv(jj,3)-i) == 0) %next sharing element is sharing local node ID 3 with i
           nb_tmp(j,2)=3;
         end
       end

       for j=2:ntve(i)+1
         nbve(i,j)=nb_tmp(j,1); %reord the next sharing element in nbve
       end

       for j=2:ntve(i)+1        %record the corresponding element's local node ID
         nbvt(i,j)=nb_tmp(j,2);
       end

       %check if the last point returns to the begging point
       ntmp=ntve(i)+1;
       if(nbve(i,1) ~= nbve(i,ntmp))  %check the element
          error(['nbve(' int2str(i) ') not correct']);
       end
       if(nbvt(i,1) ~= nbvt(i,ntmp))  %check the element's sharing local node ID (1,2,3)
          error(['nbvt(' num2str(i) ') not correct']); 
       end

       %record the number of surrounding nodes
       ntsn(i)=ntve(i);

       for j=1:ntsn(i)
         ii=nbve(i,j) ; %fetch the j'th surrounding element of node i
         jj=nbvt(i,j) ; %fetch the sharing element's local sharing node ID
         nbsn(i,j)=nv(ii,jj+1-floor((jj+1)/4)*3);  %get the next node 
                                                 %in the sharing element
                                                %i.e. the one that is not shared
		       %all surrounding nodes of node i are found
                       %through the surrounding element's non-sharing nodes
       end

       ntsn(i)=ntsn(i)+1   ;       %the last one
       nbsn(i,ntsn(i))=nbsn(i,1);  %repeats the first one

     else    %else if node i is on a boundary
       jjb=0;
       for j=1:ntve(i)  %loop through all surrounding elements
                        %of node i
         jj=nbvt(i,j) ;  %1,2 or 3. i.e. the jj'th node of 
			%the surrounding elemnt j of node i
         if(nbe(nbve(i,j),jj+2-floor((jj+2)/4)*3) == 0)  
           jjb=jjb+1;
           nb_tmp(jjb,1)=nbve(i,j) ; %element number of an element surrounding node i
           nb_tmp(jjb,2)=nbvt(i,j) ; %local node number of the surrounding element
         end
       end

       if(jjb ~= 1)
         error(['error in isonb i,j=',int2str(i),',',int2str(j)]);
       end

       for j=2:ntve(i)
         ii=nb_tmp(j-1,1);
         jj=nb_tmp(j-1,2);
         nb_tmp(j,1)=nbe(ii,jj+1-floor((jj+1)/4)*3);
         jj=nb_tmp(j,1);
         if((nv(jj,1)-i) == 0)
            nb_tmp(j,2)=1;
         end
         if((nv(jj,2)-i) == 0)
            nb_tmp(j,2)=2;
         end
         if((nv(jj,3)-i) == 0)
            nb_tmp(j,2)=3;
         end
       end

       for j=1:ntve(i)
         nbve(i,j)=nb_tmp(j,1);
         nbvt(i,j)=nb_tmp(j,2);
       end

       nbve(i,ntve(i)+1)=0;

       ntsn(i)=ntve(i)+1;
       nbsn(i,1)=i;

       for j=1:ntsn(i)-1
         ii=nbve(i,j);
         jj=nbvt(i,j);
         nbsn(i,j+1)=nv(ii,jj+1-floor((jj+1)/4)*3);
       end

       j=ntsn(i);
       ii=nbve(i,j-1);
       jj=nbvt(i,j-1);
       nbsn(i,j+1)=nv(ii,jj+2-floor((jj+2)/4)*3);
       ntsn(i)=ntsn(i)+2;
       nbsn(i,ntsn(i))=i;
     end
   end

%   deallocate(nb_tmp)
   clear 'nb_tmp';

   if(mx_nbr_elem+3 -max(ntsn(:)) < 0)
      error(['check ntsn/nbsn',num2str(max(ntsn(:))),num2str(mx_nbr_elem+3)]);
   end

   display(['  nbve/nbvt           :    complete']); 
     

%==============================================================================%
%  define the parameters of each triangular edge                               %
%                                                                              %
%  ne           :    number of unique element edges                            %
%  iec(1:ne,1:2):    counting number identifying two connected cells           %
%  isbc(1:ne):       0: triangle s edge in the interior                        %
%                    1: triangle s edge on the boundary                        %
%  ienode(1:ne,1:2): the identification number of two end points of a          %
%                    edge                                                      %
%                    Wen Long: the order of ienode(i,1) to ienode(i,2) is      %
%                              counter-clockwise for element iec(i,1) (left    %
%                              element)                                        %
%                              and clockwise (right element)                   %
%                              for element iec(i,2)                            %
%                                                                              %
%  xijc(1:ne):       the x-coordinate location of the middle points            %
%                    of a edge                                                 %
%  yijc(1:ne):       the y-coordinate location of the middle points            %
%                    of a edge                                                 %
%  dltxyc(1:ne):     length of the edge                                        %
%  dltxc(1:ne):      vx(ienode(i,2))-vx(idnode(i,1))                           %
%  dltyc(1:ne):      vy(ienode(i,2))-vy(idnode(i,1))                           %
%  sitac(1:ne):      arctg(dltyc,dltxc)                                        %
%==============================================================================%

   %collect all edges in the grid

   %maximum number of edges = nt*3 (i.e. number of traingles * 3)
   %because each element can have 3 eldges

   iset=zeros([nt,3]); 
   temp=zeros([nt*3,2]);

   temp2=zeros([nt*3,2]); 
 
   ne = 0;

   for i=1:nt  %loop through all elements 
 
     for j=1:3 %loop through all nodes (1,2,3) of the element

       if(iset(i,j) == 0)  %if this elelemnt's edge j has not been checked 

         ne   = ne + 1   ;  %reigster a new edge 
         iney = nbe(i,j) ;  %find the new edge's neighboring element
                            %i.e. the element i'th neighboring element that is 
                            %opposite to node j

         iset(i,j) = 1;    %mark this edge has being checked

         for jn=1:3
           if(iney>0)
	           if(i == nbe(iney,jn)) %check the neighbor element's neihboor
                                 %if the neihbor 's neighbor turns out to be i itself
        	      iset(iney,jn) = 1; %then mark the neighbor's edge jn as being checked already
	           end
           end
         end

         temp(ne,1) = i;    %element number of edge ne
         temp(ne,2) = iney; %another sharing element number of edge ne

         %starting and ending nodes of the edge ne (which is the edge that element i 
         %                                         shares with and that does not have
         %                                         local node j (opposite to node j))

         temp2(ne,1) = nv(i,j+1-floor((j+1)/4)*3);  %j+1'th node number of element i
         temp2(ne,2) = nv(i,j+2-floor((j+2)/4)*3);  %j+2'th node number of element i
                                %note that j+1 and j+2 are in counter-clockwise order for element
                                %hence clockwise for the element that is on the other
                                %side of the shared edge !!! 
       end
     end
   end

%   deallocate(iset)
   clear 'iset'; 
%
%--allocate arrays requiring number of edges-----------------------------------%
%
%   allocate(iec(ne,2))
%   allocate(ienode(ne,2))
%   allocate(xijc(ne))
%   allocate(yijc(ne)
%   allocate(dltxyc(ne))
%   allocate(dltxc(ne))
%   allocate(dltyc(ne))
%   allocate(sitac(ne))
%   allocate(isbc(ne))

   iec=zeros([ne,2]); 
   ienode=zeros([ne,2]);
   xijc=zeros([ne,1]);
   yijc=zeros([ne,1]);
   dltxyc=zeros([ne,1]);
   dltxc=zeros([ne,1]);
   dltyc=zeros([ne,1]);
   sitac=zeros([ne,1]);
   isbc=zeros([ne,1]); 

   iec(:,1) = temp(1:ne,1) ; %elements that shares an edge
   iec(:,2) = temp(1:ne,2) ;

   ienode(:,1) = temp2(1:ne,1) ; %starting and ending nodes of an edge
   ienode(:,2) = temp2(1:ne,2) ;

 %   Wen Long: the order of ienode(i,1) to ienode(i,2) is      
 %             counter-clockwise for exlement iec(i,1)
 %             and clockwise for element iec(i,2)
 %                                                                              

%   deallocate(temp,temp2)
   clear 'temp' 'temp2'  ;
         
%
%------mark element edges that are on the boundary-----------------------------%
%
   isbc(:) = 0;

   for i=1:ne
     if((iec(i,1) == 0) || (iec(i,2) == 0))
         isbc(i) = 1 ;
     end
   end

%
%------calculate element edge metrics------------------------------------------%
%
if(spherical)
   for i=1:ne
     x1_dp=vx(ienode(i,1));
     y1_dp=vy(ienode(i,1));
     x2_dp=vx(ienode(i,2));
     y2_dp=vy(ienode(i,2));

     [xxc,yyc]=arcc_fvcom(x2_dp,y2_dp,x1_dp,y1_dp);

     [side]=arcx_fvcom(x1_dp,y1_dp,x2_dp,y2_dp);

     xtmp  = vx(ienode(i,2))*tpi-vx(ienode(i,1))*tpi;
     xtmp1 = vx(ienode(i,2))-vx(ienode(i,1));

     if(xtmp1 > 180.0)
       xtmp = -360.0*tpi+xtmp;
     elseif(xtmp1 < -180.0)
       xtmp = 360.0*tpi+xtmp;
     end
     dltxc(i) =xtmp*cos(deg2rad*(vy(ienode(i,2))+vy(ienode(i,1)))*0.5);
     dltyc(i) =(vy(ienode(i,2))-vy(ienode(i,1)))*tpi;

     side= arc_fvcom(x1_dp,y1_dp,x2_dp,y2_dp);   %to implement arc

     dltxyc(i) = side;
     sitac(i)  = atan2(dltyc(i),dltxc(i));       
     xijc(i)   = xxc;
     yijc(i)   = yyc;                           
   end
else
   for i=1:ne
     dltxc(i) =  vx(ienode(i,2))-vx(ienode(i,1));
     dltyc(i) =  vy(ienode(i,2))-vy(ienode(i,1));
     xijc(i)  = (vx(ienode(i,1))+vx(ienode(i,2)))/2.0;
     yijc(i)  = (vy(ienode(i,1))+vy(ienode(i,2)))/2.0;
     dltxyc(i)= sqrt(dltxc(i)^2+dltyc(i)^2);
     sitac(i) = atan2(dltyc(i),dltxc(i));
   end
end

   display(['  edge setup          :    complete']);


%==============================================================================%
%  read triangular mesh parameters on open boundary :                          %
%  iobce:   number of open boundary cells.                                     %
%  isbcn:   number of open boundary nodes.                                     %
%  i_obc_e: element number of open boundary cells                              %
%  i_obc_n: node number of open boundary nodes                                 %
%==============================================================================%

%
%----traverse  boundary node numbers and set isonb(node)=2---------------------%
%
   for i=1:iobcn
     isonb(i_obc_n(i))=2;
   end

%
%----determine if element is on open boundary (contains edge on open boundary)-%
%
   ibcetmp=0;
   for i=1:n
     itmp1=isonb(nv(i,1));
     itmp2=isonb(nv(i,2));
     itmp3=isonb(nv(i,3));

     if(sum(isonb(nv(i,1:3))) == 4)
       isbce(i)=2;
       ibcetmp =ibcetmp+1;
     elseif(sum(isonb(nv(i,1:3))) > 4)

if(multiprocessor)
       display(['sorry, the boundary cell ',num2str(ngid(i)),' is not good for model.']);
else
       display(['sorry, the boundary cell ',int2str(i),' is not good for model.']);
end
       display(['it has either two sides of open boundary or one open boundary']);
       display(['and one solid boundary. please check and modified it.']);
       display(['this message is in subroutine triangle_grid_edge (tge.f)']);
       display(['stop running...']);
       exit;
     end
   end

   for i=1:nt
     if((nbe(i,1)+nbe(i,2)+nbe(i,3) == 0) && (isbce(i) ~= 2))
         isbce(i)=3;
     end
     if((nbe(i,1)+nbe(i,2) == 0) && (isbce(i) ~= 2))
          isbce(i)=3;
     end
     if((nbe(i,2)+nbe(i,3) == 0) && (isbce(i) ~= 2))
          isbce(i)=3;
     end
     if((nbe(i,1)+nbe(i,3) == 0) && (isbce(i) ~= 2))
          isbce(i)=3;
     end
   end

%==============================================================================%
%  xije(1:nc,1:2):  the x coordinate locations of starting and ending          %
%                   points of the control volumes edges                        %
%  yije(1:nc,1:2):  the y coordinate locations of starting and ending          %
%                   points of the control volumes edges                        %
%  niec(1:nc,1:2):  the counting number of left and right nodes                %
%                   conected to this control volumes edge from                 %
%                   starting point to ending point                             %
%  dltxe(1:nc):     the x distance of individual edges                         %
%  dltye(1:nc)      the y distance of individual edges                         %
%  dltxye(1:nc):    the length of individual edges                             %
%  ntrg(1:nc)  :    element associated with this control volume edge           %
%                     i.e. element that the TCE edge belongs to                %
%  sitae       :    angle of the TCE edge (pointing to the element that        %
%                   shares an edge with ntrg                                   %
%==============================================================================%
   nctmp  = 0;
   ncetmp = 0 ;

   for i=1:ne                     %loop over all edges

     if(isbc(i) == 0)             %if the edge is in interior
       if(iec(i,1) <= n)          %check the cell on one side (which side?? left or right?)to see if it is a good cell number 
                                  %note here n is local domain's cell 
         nctmp=nctmp+1 ;           %if yes increment nctmp
         npt  =nctmp   ;           %and also follow with npt
       else
         ncetmp = ncetmp + 1    ;  % if iec(i,1) > n, then put npt behind 3*n
         npt    = ncetmp+(3*n)  ;  % i.e. give room for those that are <=n 
       end

       xije(npt,1) = xc(floor(iec(i,1))) ; %take the center of the cell on one side
       yije(npt,1) = yc(floor(iec(i,1))) ;

       xije(npt,2) = xijc(i) ;     %take the mid-point of the edge
       yije(npt,2) = yijc(i) ;

       niec(npt,1) = ienode(i,1) ;  %record first node number of the edge
       niec(npt,2) = ienode(i,2) ;  %record second node number of the edge

       ntrg(npt)   = iec(i,1) ;     %record the element number that this TCE edge (xije(1),yije(1)) ~ (xije(2),yije(2)) belongs to


       dltxe(npt)  = xije(npt,2)-xije(npt,1);
       dltye(npt)  = yije(npt,2)-yije(npt,1); 

if(spherical)
       x1_dp=xije(npt,1);
       y1_dp=yije(npt,1);
       x2_dp=xije(npt,2);
       y2_dp=yije(npt,2);
       [xxc,yyc]= arcc_fvcom(x2_dp,y2_dp,x1_dp,y1_dp);  %need implement arcc
% for global case when vx change from 360 to 0 or from 0 to 360 (degree)       
       xtmp  = xije(npt,2)*tpi-xije(npt,1)*tpi;
       xtmp1 = xije(npt,2)-xije(npt,1);
       if(xtmp1 >  180.0)
         xtmp = -360.0*tpi+xtmp;
       elseif(xtmp1 < -180.0)
         xtmp =  360.0*tpi+xtmp;
       end	 
%       dltxe(npt)=tpi*dltxe(npt)*cos(deg2rad*yyc)
       dltxe(npt)=xtmp*cos(deg2rad*y1_dp);
       dltye(npt)=tpi*dltye(npt);

       dtmp_db=arc_fvcom(x1_dp,y1_dp,x2_dp,y2_dp)  ;

       dltxye(npt)=dtmp_dp;
       sitae(npt)=atan2(dltye(npt),dltxe(npt));
       dltxne(i,1) = dltxe(npt);
       dltyne(i,1) = dltye(npt);
else
       dtmp        = dltxe(npt)*dltxe(npt)+dltye(npt)*dltye(npt);
       dltxye(npt) = sqrt(dtmp);
       sitae(npt)  = atan2(dltye(npt),dltxe(npt));  %angle of the TCE edge npt
end

       if(iec(i,2) <= n)     %check the other side element of the edge
         nctmp=nctmp+1 ;      %if the element number is <=n then increment nctmp too
         npt  =nctmp   ;
       else                   %if element number>n then record them behind 3*n
         ncetmp = ncetmp + 1   ;
         npt    = ncetmp+(3*n) ;
       end

       xije(npt,1)=xc(iec(i,2)); %start from center of the element
       yije(npt,1)=yc(iec(i,2)); 
       xije(npt,2)=xijc(i)    ;  %ends at the mid point of edge i
       yije(npt,2)=yijc(i)   ;

       niec(npt,1)=ienode(i,2);  %record the node numbers  of the element edge that this TCE edge npt is 
                                 %intersecting with at the midpoint
       niec(npt,2)=ienode(i,1);  %note the switch of order, this makes sure niec(npt,1) is always on
                                 %right side of the TCE edge 
                                 %and niec(npt,2) is always on left hand side of the TCE edge
                                 %if one walks from the starting point of the TCE edge to the 
                                 %ending point of the TCE edge

       ntrg(npt)=iec(i,2)     ;  %record the element number that this TCE edge npt belong to

       dltxe(npt)=xije(npt,2)-xije(npt,1) ; %vector from cell center to mid-point of edge i
       dltye(npt)=yije(npt,2)-yije(npt,1) ; %

if(spherical)
       x1_dp=xije(npt,1)   ;
       y1_dp=yije(npt,1)   ;
       x2_dp=xije(npt,2)   ;
       y2_dp=yije(npt,2)   ;
       [xxc,yyc]= arcc_fvcom(x2_dp,y2_dp,x1_dp,y1_dp) ; %arcc needs implementation
% for global case when vx change from 360 to 0 or from 0 to 360 (degree)       
       xtmp  = xije(npt,2)*tpi-xije(npt,1)*tpi;
       xtmp1 = xije(npt,2)-xije(npt,1);
       if(xtmp1 >  180.0)
         xtmp = -360.0*tpi+xtmp;
       elseif(xtmp1 < -180.0)
         xtmp =  360.0*tpi+xtmp;
       end	 
%       dltxe(npt)=tpi*dltxe(npt)*cos(deg2rad*yyc)
       dltxe(npt)=xtmp*cos(deg2rad*y1_dp);
       dltye(npt)=tpi*dltye(npt);
       dtmp_dp=arc_fvcom(x1_dp, y1_dp, x2_dp, y2_dp);  %arcc needs implementation
       dltxye(npt)=dtmp_dp;
       sitae(npt)=atan2(dltye(npt),dltxe(npt));
       dltxne(i,2) = dltxe(npt);
       dltyne(i,2) = dltye(npt);
else
       dtmp=dltxe(npt)*dltxe(npt)+dltye(npt)*dltye(npt)  ;
       dltxye(npt)=sqrt(dtmp)                            ;      %length of this TCE edge npt
       sitae(npt)=atan2(dltye(npt),dltxe(npt))           ;      %angle of this TCE edge npt
end

     elseif(isbc(i) == 1)                          %if the element edge i is on boundary
       if(iec(i,1) <= n)                           %check if side element is in domain
         nctmp=nctmp+1           ;                  %if yes increment npt by one
         npt  =nctmp             ;
       else
         ncetmp = ncetmp + 1     ;
         npt    = ncetmp+(3*n)   ;                  %else increment by one and off set by 3*n
       end

       if(iec(i,1) == 0)                           %if element doesn't exist then abort
         display(['iec(' int2str(i)','1)===0']);   
         exit;
       end

                                                   %found one TCE edge
       xije(npt,1)=xc(iec(i,1))   ;                 %starts from the element center
       yije(npt,1)=yc(iec(i,1))   ;                 
       xije(npt,2)=xijc(i)        ;                 %ends at mid point of the edge
       yije(npt,2)=yijc(i)        ;

       niec(npt,1)=ienode(i,1)   ;                  %record the node numbers of the edge that 
       niec(npt,2)=ienode(i,2)   ;                  %this TCE edge npt is purpendicular to
       ntrg(npt)=iec(i,1)        ;                  %record the element number that this TCE edge belongs to 

       dltxe(npt)=xije(npt,2)-xije(npt,1);	   %vector from center of element to midpoint of edge
       dltye(npt)=yije(npt,2)-yije(npt,1);          %

if(spherical)
       x1_dp= xije(npt,1);
       y1_dp= yije(npt,1);
       x2_dp= xije(npt,2);
       y2_dp= yije(npt,2);
       [xxc,yyc]=arcc_fvcom(x2_dp,y2_dp,x1_dp,y1_dp);
% for global case when vx change from 360 to 0 or from 0 to 360 (degree)       
       xtmp  = xije(npt,2)*tpi-xije(npt,1)*tpi;
       xtmp1 = xije(npt,2)-xije(npt,1);
       if(xtmp1 >  180.0)
         xtmp = -360.0*tpi+xtmp;
       elseif(xtmp1 < -180.0)
         xtmp =  360.0*tpi+xtmp;
       end
%       dltxe(npt)=tpi*dltxe(npt)*cos(deg2rad*yyc)
       dltxe(npt)=xtmp*cos(deg2rad*y1_dp);
       dltye(npt)=tpi*dltye(npt);
       dtmp_dp=arc_fvcom(x1_dp,y1_dp,x2_dp,y2_dp);  %arc needs implementation
       dltxye(npt)=dtmp_dp;
       sitae(npt)=atan2(dltye(npt),dltxe(npt));
       dltxne(i,1) = dltxe(npt);
       dltyne(i,1) = dltye(npt);
       dltxne(i,2) = 0.0;
       dltyne(i,2) = 0.0;
else
       dtmp=dltxe(npt)*dltxe(npt)+dltye(npt)*dltye(npt)   ;
       dltxye(npt)=sqrt(dtmp)                            ; %length of TCE edge npt
       sitae(npt)=atan2(dltye(npt),dltxe(npt))           ; %angle of TCE edge npt
                                                          %angle is the angle 
                                                          %of the normal vector pointing 
                                                          %to exterior (the element on 
                                                          %the opposite side of edge i)
end
     else 
       display(['isbc(i) not correct, i==',int2str(i)]); 
       exit;
     end
   end


   %each element in the model should contribute 3 TCE edges
   %hence ncv must be qual to 3*nt

   ncv_i  = nctmp        ;  %number of TCE edges inside domain
   ncv    = ncetmp+nctmp ;  %ncetmp is number of TCE edges outside of domain      
                            %ncv is total number of TCE edges

   if(ncv ~= 3*(nt))
     display(['ncv is not correct, please check the setup']);
     exit;
   end

   if (ncv_i ~= 3*n) 
     display(['ncv_i is not correct, please check the setup']);
     exit;
   end

   %
   %check all in-domain TCE edges,
   %
   for i=1:ncv_i
     if(niec(i,1) > m || niec(i,2) > m) %make sure nodes of the edge that TCE edge i is
                                        %purpendicular to are in the domain as well
       display(['problem as ,niec(i,1),niec(i,2),m=' num2str(niec(i,1)) ',' num2str(niec(i,2)) ',' num2str(m)]);
       exit;
     end

   end

%calculate deltux,deltuy and sitau for spherical coordinates only

if(spherical)
   for i=1:n                    %loop through all elements
     for j = 1:3                %loop thorugh all nodes of the element

       j1=j+1-(j+1)/4*3     ;    %get the starting (j1) and ending (j2) node  number of the 
       j2=j+2-(j+2)/4*3     ;    %edge that is opposite to node j in element i
       deltx=vx(nv(i,j2))-vx(nv(i,j1)) ;  %get the edge vector (pointing from j1 to j2)
       delty=vy(nv(i,j2))-vy(nv(i,j1)) ;

       x1_dp=vx(nv(i,j1))     ;           %get the edge ends location
       y1_dp=vy(nv(i,j1))     ;

       x2_dp=vx(nv(i,j2))     ;
       y2_dp=vy(nv(i,j2))     ;

       side=arcx_fvcom(x1_dp,y1_dp,x2_dp,y2_dp)   ;
       deltux(i,j)= side                          ; %
       deltuy(i,j)= tpi*delty;
       sitau(i,j)=atan2(deltuy(i,j),deltux(i,j))  ; %get the angle of the edge (j1 to j2)
                                                    %
     end
   end

end

%==============================================================================%
%  nisbce_1/nisbce_2/nisbce_3:  number of elements with isbce of 1,2,3         %
%  lisbce_1/lisbce_2/lisbce_3:  list of elements with isbce of 1,2,3           %
%  epor                      :  element porosity (=0 if isbce = 2)             %
%==============================================================================%

%
%--count number of elements of each type (isbce=1,2,3)-------------------------%
%
   nisbce_1 = 0 ; 
   nisbce_2 = 0 ;
   nisbce_3 = 0 ;

   for i=1:n 
     if(isbce(i) == 1)
         nisbce_1 = nisbce_1 + 1;
     end
     if(isbce(i) == 2)
         nisbce_2 = nisbce_2 + 1;
     end
     if(isbce(i) == 3)
         nisbce_3 = nisbce_3 + 1;
     end
   end

%
%--allocate element type arrays lisbce_1,lisbce_2,lisbce_3---------------------%
%
   lisbce_1=[];
   if(nisbce_1 > 0)
      lisbce_1=zeros([nisbce_1,1]);
   else
     display(['  warning             :    no elements with isbce=1']);
   end
   lisbce_2=[];

   if(nisbce_2 > 0)
      lisbce_2=zeros([nisbce_2,1]);    
   else
     display(['  warning             :    no elements with isbce=2']);
   end
   lisbce_3=[];     
   if(nisbce_3 > 0)
     lisbce_3=zeros([nisbce_3,1]);
   else
     display(['  warning             :    no elements with isbce=3']);
   end

%
%--load element type arrays lisbce_1,lisbce_2,lisbce_3--------------------------%
%
   nisbce_1 = 0 ; 
   nisbce_2 = 0 ; 
   nisbce_3 = 0 ;

   for i=1:n 
     if(isbce(i) == 1)
       nisbce_1 = nisbce_1 + 1 ;
       lisbce_1(nisbce_1) = i  ;
     end
     if(isbce(i) == 2)
       nisbce_2 = nisbce_2 + 1 ;
       lisbce_2(nisbce_2) = i  ;
     end
     if(isbce(i) == 3) 
       nisbce_3 = nisbce_3 + 1 ;
       lisbce_3(nisbce_3) = i  ;
     end
   end

%
%--set element porosity---------------------------------------------------------%
% allocate(epor(0:nt)) ; epor = 1.0
%  
   epor=zeros([nt,1]); 
   for i=1:n
     if(isbce(i) == 2)
         epor(i) = 0.0;
     end
   end 


   display(['  nisbce/lisbce/epor  :    complete']);
   display(['  tris/edges/cvols    :    complete']); 

   %set return values of spherical coordinate related outputs  to empty if non-spherical

   if(~spherical)
      sitau=[];
      dltxne=[];
      dltyne=[];
      deltux=[];
      deltuy=[];

   end

end

